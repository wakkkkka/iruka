# データ保存設計：アプリ側 vs バックエンド

## 全体方針

```
ユーザー操作
    ↓
┌─────────────────────────────────┐
│  Flutter アプリ（フロント）        │
│                                  │
│  ローカルストレージ               │
│  ・ログイン状態                   │
│  ・撮影した写真の一時キャッシュ    │
│  ・直近の着用ログ（オフライン用）  │
│  ・UIの設定値                     │
└──────────┬──────────────────────┘
           │ API通信（オンライン時）
           ↓
┌─────────────────────────────────┐
│  AWS バックエンド                 │
│                                  │
│  S3         : 服画像・自撮り画像  │
│  DynamoDB   : 服マスタ・着用ログ  │
│  Rekognition: 画像解析           │
│  Lambda     : マッチングロジック  │
└─────────────────────────────────┘
```

---

## 1. バックエンド（AWS）で保存するデータ（正データ）

バックエンドが**信頼できる唯一の情報源（Single Source of Truth）**。

### DynamoDB: `Clothes` テーブル（服マスタ）
| フィールド     | 型       | 説明                              |
|---------------|----------|-----------------------------------|
| id            | String   | 服のユニークID（UUID）             |
| userId        | String   | ユーザーID                         |
| category      | String   | Tシャツ, パーカー, コート, etc.    |
| color         | String   | 白, 黒, グレー, etc.              |
| itemName      | String   | ユーザーがつけた名前               |
| tags          | List     | AIが検出したラベル + ユーザー追加タグ |
| imageKey      | String   | S3上の画像キー                     |
| createdAt     | String   | 登録日時（ISO 8601）               |

### DynamoDB: `UsageLogs` テーブル（着用ログ）
| フィールド     | 型       | 説明                              |
|---------------|----------|-----------------------------------|
| id            | String   | ログのユニークID                   |
| userId        | String   | ユーザーID                         |
| clothId       | String   | 着た服のID（Clothesテーブルと紐づけ） |
| date          | String   | 着用日（YYYY-MM-DD）               |
| selfieKey     | String   | 自撮り画像のS3キー                 |
| createdAt     | String   | 記録日時                           |

### S3 バケット
| パス                              | 用途                    |
|-----------------------------------|------------------------|
| `clothes/{userId}/{clothId}.jpg`  | 服の平置き/スクショ画像   |
| `selfies/{userId}/{date}_{id}.jpg`| その日の自撮り画像       |

---

## 2. アプリ側（ローカル）で保存するデータ

アプリ側は**キャッシュ + 一時データ**。バックエンドが落ちてても最低限使えるようにする。

### shared_preferences（軽量 Key-Value）
| キー                | 型      | 説明                                      |
|--------------------|---------|-------------------------------------------|
| `auth_token`       | String  | ログイントークン（Cognito等）               |
| `user_id`          | String  | ログイン中のユーザーID                      |
| `user_name`        | String  | 表示用ユーザー名                           |
| `is_logged_in`     | bool    | ログイン状態フラグ                          |
| `last_sync_at`     | String  | 最後にバックエンドと同期した日時             |

### ローカルファイル（path_provider）
| パス                          | 用途                              |
|------------------------------|-----------------------------------|
| `tmp/camera_*.jpg`           | 撮影直後の一時画像（解析前）        |
| `cache/clothes/{id}.jpg`     | 服画像のローカルキャッシュ          |

### SQLite or shared_preferences（オフラインキャッシュ）
| データ                | 説明                                          |
|----------------------|-----------------------------------------------|
| `cached_clothes`     | 服一覧のキャッシュ（起動時に表示高速化）          |
| `cached_logs`        | 直近30日分の着用ログ（オフライン閲覧用）          |
| `pending_uploads`    | オフライン中に追加された服・ログ（次回同期時送信） |

---

## 3. データの流れ（画面ごと）

### 服の新規登録（平置き撮影）
```
1. ユーザーが平置き写真を撮影
2. → ローカルに tmp/ 保存
3. → S3 にアップロード
4. → Lambda が Rekognition で解析 → タグ生成
5. → ユーザーがタグを確認・編集
6. → DynamoDB Clothes に保存
7. → アプリ側 cached_clothes を更新
```

### 今日の着用記録（自撮り）
```
1. ユーザーが自撮り撮影
2. → ローカルに tmp/ 保存
3. → S3 にアップロード
4. → Lambda が Rekognition で解析
5. → DynamoDB Clothes から候補をマッチング
6. → ユーザーが「これを着た」を選択
7. → DynamoDB UsageLogs に保存
8. → アプリ側 cached_logs を更新
```

### 統計画面の表示
```
1. cached_logs があればまず表示（高速）
2. バックグラウンドで API から最新ログ取得
3. 差分があれば cached_logs を更新 & 画面を再描画
```

### カレンダー画面
```
1. cached_logs から当月分を表示
2. 日付タップ → cached_logs からその日のログ取得
3. 服の詳細は cached_clothes から画像付き表示
```

---

## 4. フェーズ別の実装計画

### フェーズ1（〜2/20）：フロントのみ、ダミーデータ
- バックエンド未接続
- **全データをアプリ内のハードコードで持つ**（現状の `dummyWearLogs` など）
- 画面の動きとUIを完成させることが目的
- この段階では shared_preferences も不要（メモリ上のダミーで十分）

### フェーズ2（2/21）：AWS接続
- バックエンド担当（Aoi・石橋）が API を用意
- フロントはダミーデータ参照部分を **API呼び出しに差し替え**
- 画像アップロード → S3
- ログイン → Cognito (or 簡易認証)
- ローカルキャッシュ（shared_preferences）を導入して高速化

### フェーズ3（2/22）：最終調整
- オフライン対応（pending_uploads）
- 統計の集計をバックエンド側 Lambda で行う or フロントで行うか判断
- UIの仕上げ

---

## 5. フロント担当（高橋・汐）の今やること

フェーズ1 ではバックエンドがないので、**画面に必要なデータの「形」だけ決めておく**ことが重要。

具体的には：
1. **データモデルクラスの定義**（`ClothItem`, `WearLog`）
   - フィールドだけ決めてファイルに分離する
   - `toMap()` / `fromMap()` も書いておくとフェーズ2で即使える
2. **ダミーデータを外部ファイルに分離**
   - 現在 `statistics_page.dart` にべた書きされているものを `lib/data/` に移動
3. **各画面は「データの取得元」を直接知らない設計にする**
   - 今は `dummyWearLogs` を直接参照 → 将来 API に差し替えやすくする
   - Repository パターンまでは不要、まずは関数で抽象化する程度でOK

---

## 6. バックエンド担当（Aoi・石橋）に伝えること

フロントが必要とする API のエンドポイント：

| メソッド | パス                    | 用途                        |
|---------|------------------------|-----------------------------|
| GET     | `/clothes`             | 服一覧を取得                 |
| POST    | `/clothes`             | 服を新規登録                 |
| DELETE  | `/clothes/{id}`        | 服を削除                     |
| GET     | `/logs`                | 着用ログ一覧（期間指定可）    |
| POST    | `/logs`                | 着用ログを記録               |
| DELETE  | `/logs/{id}`           | 着用ログを削除               |
| POST    | `/analyze`             | 画像を送って解析（Rekognition）|
| POST    | `/match`               | 自撮りから服を候補マッチング   |

リクエスト/レスポンスの JSON は上記テーブル定義に準拠。
